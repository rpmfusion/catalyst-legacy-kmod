diff -uNrp lib/modules/fglrx/build_mod/drm_proc.h lib/modules/fglrx/build_mod/drm_proc.h
--- lib/modules/fglrx/build_mod/drm_proc.h
+++ lib/modules/fglrx/build_mod/drm_proc.h
@@ -95,22 +95,35 @@ struct proc_dir_entry *DRM(proc_init)(dr
 	int		      i, j;
 	char                  name[64];
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	if (!minor) root = create_proc_entry("dri", S_IFDIR, NULL);
+#else
+	if (!minor) root = proc_mkdir("dri", NULL);
+#endif
 	if (!root) {
 		DRM_ERROR("Cannot create /proc/ati\n");
 		return NULL;
 	}
 
 	sprintf(name, "%d", minor);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	*dev_root = create_proc_entry(name, S_IFDIR, root);
+#else
+	*dev_root = proc_mkdir(name, root);
+#endif
 	if (!*dev_root) {
 		DRM_ERROR("Cannot create /proc/ati/%s\n", name);
 		return NULL;
 	}
 
 	for (i = 0; i < DRM_PROC_ENTRIES; i++) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 		ent = create_proc_entry(DRM(proc_list)[i].name,
 					S_IFREG|S_IRUGO, *dev_root);
+#else
+		ent = proc_create_data(DRM(proc_list)[i].name,
+					S_IFREG|S_IRUGO, *dev_root, &firegl_fops, dev);
+#endif
 		if (!ent) {
 			DRM_ERROR("Cannot create /proc/ati/%s/%s\n",
 				  name, DRM(proc_list)[i].name);
@@ -121,8 +134,10 @@ struct proc_dir_entry *DRM(proc_init)(dr
 			if (!minor) remove_proc_entry("dri", NULL);
 			return NULL;
 		}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 		ent->read_proc = DRM(proc_list)[i].f;
 		ent->data      = dev;
+#endif
 	}
 
 	return root;
diff -uNrp lib/modules/fglrx/build_mod/firegl_public.c lib/modules/fglrx/build_mod/firegl_public.c
--- lib/modules/fglrx/build_mod/firegl_public.c
+++ lib/modules/fglrx/build_mod/firegl_public.c
@@ -16,6 +16,10 @@
 
 #ifdef __KERNEL__
 
+#ifndef VM_RESERVED
+#define VM_RESERVED (VM_DONTEXPAND | VM_DONTDUMP)
+#endif
+
 #ifndef MODULE
 !!! This is not currently supported,
 !!! since it requires changes to linux/init/main.c.
@@ -196,6 +200,10 @@
 #include "kcl_io.h"
 #include "kcl_debug.h"
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+#include <linux/seq_file.h>
+#endif
+
 // ============================================================
 
 // VM_SHM is deleted in 2.6.18 or higher kernels.
@@ -222,6 +230,11 @@
 #define preempt_enable()
 #endif
 
+// VM_RESERVED is removed from 3.7.0
+#ifndef VM_RESERVED
+#define VM_RESERVED				VM_DONTEXPAND | VM_DONTDUMP
+#endif
+
 // ============================================================
 /* globals */
 
@@ -250,7 +263,13 @@ module_param(firegl, charp, 0);
 #endif
 
 #ifdef MODULE_LICENSE
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0)
 MODULE_LICENSE("Proprietary. (C) 2002 - ATI Technologies, Starnberg, GERMANY");
+#else
+MODULE_LICENSE("GPL\0Proprietary. (C) 2002 - ATI Technologies, Starnberg, GERMANY");
+#endif
+
 #endif
 #ifdef MODULE_DEVICE_TABLE
 MODULE_DEVICE_TABLE(pci, fglrx_pci_table);
@@ -508,16 +527,26 @@ READ_PROC_WRAP(firegl_lock_info)
 #ifdef DEBUG
 READ_PROC_WRAP(drm_bq_info)
 #endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 READ_PROC_WRAP(firegl_debug_proc_read)
+#endif
 READ_PROC_WRAP(firegl_bios_version)
 READ_PROC_WRAP(firegl_interrupt_info)
 READ_PROC_WRAP(firegl_ptm_info)
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 static int firegl_debug_proc_write_wrap(void* file, const char *buffer, unsigned long count, void *data)
-{                                                                  
-    return firegl_debug_proc_write(file, buffer, count, data);     
+#else
+static int firegl_debug_proc_read_wrap(struct seq_file *m, void* data)
+{
+    return firegl_debug_proc_read(m->buf, m->from, m->index, m->size, m->size - m->count, data);
 }
 
+static ssize_t firegl_debug_proc_write_wrap(struct file *file, const char *buffer, size_t count, void *data)
+#endif
+{
+	return firegl_debug_proc_write(file, buffer, count, data);
+}
 /** \brief Callback function for reading from /proc/ati/major
  *
  * Returns the major device number in the outupt buffer in decimal.
@@ -531,9 +560,14 @@ static int firegl_debug_proc_write_wrap(
  *
  * \return number of bytes written
  */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 static int firegl_major_proc_read(char *buf, char **start, kcl_off_t offset,
                                   int request, int* eof, void* data)
+#else
+static int firegl_major_proc_read(struct seq_file *m, void* data)
+#endif
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     int len = 0;    // For ProcFS: fill buf from the beginning
 
     KCL_DEBUG1(FN_FIREGL_PROC, "offset %d\n", (int)offset);
@@ -548,7 +582,9 @@ static int firegl_major_proc_read(char *
     *eof = 1;
 
     len = snprintf(buf, request, "%d\n", major);
-
+#else
+	int len = seq_printf(m, "%d\n", major);
+#endif
     KCL_DEBUG1(FN_FIREGL_PROC, "return len=%i\n",len);
 
     return len;
@@ -571,6 +607,29 @@ kcl_proc_list_t KCL_PROC_FileList[] =
     { "NULL",           NULL,                       NULL} // Terminate List!!!
 };
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+static int firegl_major_proc_open(struct inode *inode, struct file *file){
+		return single_open(file, firegl_major_proc_read, NULL);
+}
+
+static const struct file_operations firegl_major_fops = {
+		.open = firegl_major_proc_open,
+		.read = seq_read,
+		.llseek = seq_lseek,
+};
+
+static int firegl_debug_proc_open(struct inode *inode, struct file *file){
+		return single_open(file, firegl_debug_proc_read_wrap, NULL);
+}
+
+static const struct file_operations firegl_debug_fops = {
+		.open = firegl_debug_proc_open,
+		.write = firegl_debug_proc_write_wrap,
+		.read = seq_read,
+		.llseek = seq_lseek,
+};
+#endif
+
 static struct proc_dir_entry *firegl_proc_init( device_t *dev,
                                                 int minor,
                                                 struct proc_dir_entry *root,
@@ -583,7 +642,11 @@ static struct proc_dir_entry *firegl_pro
     KCL_DEBUG1(FN_FIREGL_PROC, "minor %d, proc_list 0x%08lx\n", minor, (unsigned long)proc_list);
     if (!minor)
     {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
         root = create_proc_entry("ati", S_IFDIR, NULL);
+#else
+        root = proc_mkdir("ati", NULL);
+#endif
     }
 
     if (!root)
@@ -595,18 +658,28 @@ static struct proc_dir_entry *firegl_pro
     if (minor == 0)
     {
         // Global major debice number entry
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
         ent = create_proc_entry("major", S_IFREG|S_IRUGO, root);
+#else
+        ent = proc_create("major", S_IFREG|S_IRUGO, root, &firegl_major_fops);
+#endif
         if (!ent)
         {
             remove_proc_entry("ati", NULL);
             KCL_DEBUG_ERROR("Cannot create /proc/ati/major\n");
             return NULL;
         }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
         ent->read_proc = (read_proc_t*)firegl_major_proc_read;
+#endif
     }
 
     sprintf(name, "%d", minor);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     *dev_root = create_proc_entry(name, S_IFDIR, root);
+#else
+    *dev_root = proc_mkdir(name, root);
+#endif
     if (!*dev_root) {
         remove_proc_entry("major", root);
         remove_proc_entry("ati", NULL);
@@ -616,7 +689,12 @@ static struct proc_dir_entry *firegl_pro
 
     while (list->f || list->fops)
     {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
         ent = create_proc_entry(list->name, S_IFREG|S_IRUGO, *dev_root);
+#else
+        ent = proc_create_data(list->name, S_IFREG|S_IRUGO, *dev_root, &firegl_fops,
+			(dev->pubdev.signature == FGL_DEVICE_SIGNATURE)? firegl_find_device(minor) : (dev));
+#endif
         if (!ent)
         {
             KCL_DEBUG_ERROR("Cannot create /proc/ati/%s/%s\n", name, list->name);
@@ -634,6 +712,7 @@ static struct proc_dir_entry *firegl_pro
             return NULL;
         }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
         if (list->f)
         {
             ent->read_proc = (read_proc_t*)list->f;
@@ -647,19 +726,25 @@ static struct proc_dir_entry *firegl_pro
         {
             ent->data = (dev->pubdev.signature == FGL_DEVICE_SIGNATURE)? firegl_find_device(minor) : (dev);
         }
-
+#endif
         list++;
     }
 
     if (minor == 0)
     {
         // Global debug entry, only create it once
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
         ent = create_proc_entry("debug", S_IFREG|S_IRUGO, root);
+#else
+        ent = proc_create_data("debug", S_IFREG|S_IRUGO, root, &firegl_debug_fops, dev);
+#endif
         if (ent) 
         {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
             ent->read_proc = (read_proc_t*)firegl_debug_proc_read_wrap;     
             ent->write_proc = (write_proc_t*)firegl_debug_proc_write_wrap;  
             ent->data = dev;
+#endif
         }
     }
 
@@ -2147,10 +2232,13 @@ unsigned long ATI_API_CALL KCL_MEM_Alloc
 
     flags = MAP_SHARED;
     prot  = PROT_READ|PROT_WRITE;
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+    vaddr = (void *) vm_mmap(file, 0, len, prot, flags, pgoff);
+#else
     down_write(&current->mm->mmap_sem);
     vaddr = (void *) do_mmap(file, 0, len, prot, flags, pgoff);
     up_write(&current->mm->mmap_sem);
+#endif
     if (IS_ERR(vaddr))
        return 0;
     else
@@ -2161,7 +2249,17 @@ int ATI_API_CALL KCL_MEM_ReleaseLinearAd
 {
     int retcode = 0;
 
-    down_write(&current->mm->mmap_sem);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+#ifdef FGL_LINUX_RHEL_MUNMAP_API
+	retcode = vm_munmap(addr,
+                        len,
+                        1);
+#else
+    retcode = vm_munmap(addr,
+                        len);
+#endif
+#else
+	down_write(&current->mm->mmap_sem);
 #ifdef FGL_LINUX_RHEL_MUNMAP_API
     retcode = do_munmap(current->mm,
                         addr,
@@ -2171,8 +2269,9 @@ int ATI_API_CALL KCL_MEM_ReleaseLinearAd
     retcode = do_munmap(current->mm,
                         addr,
                         len);
-#endif                        
     up_write(&current->mm->mmap_sem);
+#endif
+#endif
     return retcode;
 }
 
diff -uNrp lib/modules/fglrx/build_mod/kcl_acpi.c lib/modules/fglrx/build_mod/kcl_acpi.c
--- lib/modules/fglrx/build_mod/kcl_acpi.c
+++ lib/modules/fglrx/build_mod/kcl_acpi.c
@@ -775,11 +775,13 @@ static unsigned int KCL_ACPI_SearchHandl
 unsigned int ATI_API_CALL KCL_ACPI_GetHandles(kcl_match_info_t *pInfo)
 {
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,12)
-    #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,19)
+    #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0)
+  		pInfo->video_handle = pInfo->pcidev->dev.acpi_node.handle;
+    #elif LINUX_VERSION_CODE > KERNEL_VERSION(2,6,19)
         pInfo->video_handle = pInfo->pcidev->dev.archdata.acpi_handle;
-    #else 
+    #else
         pInfo->video_handle = pInfo->pcidev->dev.firmware_data;
-    #endif    
+    #endif
     if ( pInfo->video_handle &&
         (KCL_ACPI_videoDevice(pInfo->video_handle) != KCL_ACPI_OK) )
     {
diff -uNrp lib/modules/fglrx/build_mod/make.sh lib/modules/fglrx/build_mod/make.sh
--- lib/modules/fglrx/build_mod/make.sh
+++ lib/modules/fglrx/build_mod/make.sh
@@ -202,11 +202,23 @@ cd $current_wd
 # verify match with respective line in linux/version.h
 # sample: #define UTS_RELEASE "2.4.0-test7"
 
-src_file=$linuxincludes/linux/version.h
+# Before kernel 3.7.0 version.h is normally located at linux/version.h
+# For 3.7.0 and later version.h is in generated/uapi/linux/version.h
 
-if [ ! -e $src_file ]; then
+headerexist=0
+
+for src_file in \
+  "$linuxincludes/linux/version.h" \
+  "$linuxincludes/generated/uapi/linux/version.h";
+do
+if [ -e $src_file ]; then
+  headerexist=1
+  break
+fi
+done
+
+if [ $headerexist -eq 0 ]; then
   echo "kernel includes at $linuxincludes not found or incomplete" | tee -a $logfile
-  echo "file: $src_file"                                           | tee -a $logfile
   exit 1
 fi
 
